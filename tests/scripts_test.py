#!/usr/bin/env python
from __future__ import unicode_literals

import hashlib
import io
import os.path
import shutil
import tempfile
import unittest

import cdblib

from cdblib.cdbmake import main as python_pure_cdbmake
from cdblib.cdbdump import main as python_pure_cdbdump

from .cdblib_test import testdata_path

TYPES_DATA = (
    b'+6,1:binary->\x81\n'
    b'+4,4:text->\xf0\x9f\x95\xb4\n'
    b'+7,6:integer->102010\n'
    b'+7,3:integer->241\n'
    b'\n'
)


class ScriptsTests(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_cdbmake_known_hash(self):
        # Construct a database from text records and compare the resultant
        # file to what is generated by the official cdbmake tool
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        # `<out.cdb cdbdump | md5sum` produced the control
        self.assertEqual(
            output_hash.hexdigest(), 'dcc8b6502bcb648a71a6a080409312bb'
        )

    def test_cdbmake_64_bits(self):
        # Construct a 64-bit database with the CLI tool and read back the
        # records
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp_64.cdb')
        args = ['-64', cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        #  # Ensure that everything can be decoded properly
        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()

        reader = cdblib.Reader64(data)
        self.assertEqual(reader[b'binary'], b'\x81')
        self.assertEqual(reader.getstring(b'text'), u'\U0001f574')
        self.assertEqual(list(reader.getints(b'integer')), [102010, 241])

    def test_cdbdump_known_hash(self):
        # Dump a pre-made file to text and compare the output to what
        # is given by the official cdbdump tool
        top250_path = testdata_path('top250pws.cdb')
        with io.open(top250_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump([], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        # `<top250pws.cdb cdbdump | md5sum` produced the control
        output_hash = hashlib.md5()
        output_hash.update(data)
        self.assertEqual(
            output_hash.hexdigest(), '0564adfe4667506a326ba2f363415616'
        )

    def test_cdbdump_64_bits(self):
        # Construct a 64-bit database and then read it back with the CLI
        # tool. Since the cdbdump is text, the 64-bit database should
        # produce the same input as the 32-bit database
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        with io.open(cdb_path, 'wb') as outfile:
            writer = cdblib.Writer64(outfile)
            writer.put(b'binary', b'\x81')
            writer.putstring(b'text', u'\U0001f574')
            writer.putint(b'integer', 102010)
            writer.putint(b'integer', 241)
            writer.finalize()

        with io.open(cdb_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump(['-64'], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        self.assertEqual(data, TYPES_DATA)


if __name__ == '__main__':
    unittest.main()
